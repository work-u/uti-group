<?php

/**
 * @file
 * drs_global_functions/drs_global_functions.module Set up global functions.
 * @author mhammami
 */

/**
 * Get Web form Trouver Regime De Retraite Nid.
 *
 * @param string $title
 *   title.
 *
 * @return mixed
 *   boolean.
 */
function drs_global_functions_get_webform_trdr_nid($title = '') {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'webform')
    ->propertyCondition('title', $title);

  $result = $query->execute();

  if ($result && isset($result['node'])) {
    return key($result['node']);
  }
  return FALSE;
}

/**
 * Get_title_block.
 *
 * @param string $module
 *   module.
 *
 * @param string $delta
 *   delta.
 *
 * @return mixed
 *   title.
 */
function drs_global_functions_get_title_block($module = 'views', $delta = '') {
  $block = block_load($module, $delta);
  if ($block->title != ''):
    return $block->title;
  endif;
  return FALSE;
}

/**
 * Fonction hook menu.
 * @return array
 *   array of items.
 */
function drs_global_functions_menu() {
  $items['etudes-event'] = array(
    'title' => 'Studies and events DRS',
    'title callback' => 'Studies and events DRS',
    'access arguments' => array(TRUE),
    'type' => MENU_CALLBACK,
    'access callback' => TRUE,
    'page callback' => 'page_callback');
  $items['services'] = array(
    'title' => 'Services DRS',
    'title callback' => 'Services DRS',
    'access arguments' => array(TRUE),
    'type' => MENU_CALLBACK,
    'access callback' => TRUE,
    'page callback' => 'page_callback');
  $items['presentation'] = array(
    'title' => 'Presentation DRS',
    'title callback' => 'Presentation DRS',
    'page callback' => 'page_callback',
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  $items['organisation'] = array(
    'title' => 'Organisation',
    'title callback' => 'Organisation',
    'page callback' => 'page_callback',
    'access arguments' => array(TRUE),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  return $items;
}

/**
 * Function Page Callback, if not called from hook menu.
 *
 * Without this function pages are not displayed.
 * @return array
 *   empty.
 */
function page_callback() {
  return array();
}

/**
 * Form Alter.
 *
 * @param mixed $form
 *   form.
 *
 * @param string $form_state
 *   form state.
 *
 * @param string $form_id
 *   form_id.
 */
function drs_global_functions_form_alter(&$form, &$form_state, $form_id) {
  $nid_webform = drs_global_functions_get_webform_trdr_nid('Trouver son régime de retraite');
  switch ($form_id) {
    case "webform_client_form_{$nid_webform}":
      $form['#submit'] = array('drs_global_functions_webform_client_redirection_submit');
      break;

    default:
      break;
  }
}

  const NUMBER_COL_PER_LIGNE = 4;

/**
 * Fonction Truncate.
 *
 * @param string $text
 *   text.
 * @param int $length
 *   length.
 * @param string $ending
 *   ending.
 * @param bool $exact
 *   exact.
 * @param bool $consider_html
 *   consider_html.
 *
 * @return string
 *   truncate.
 */
function drs_global_functions_truncate($text, $length = 100, $ending = '...', $exact = FALSE, $consider_html = TRUE) {
  $escaped = array("\n", "\t", "\r");
  $text = str_replace($escaped, "", $text);
  $text_filtre = preg_replace('/&[0-9a-z]{2,8};|&#[0-9]{1,7};|[0-9a-f]{1,6};/i', ' ', $text);
  if ($consider_html) {
    // If the plain text is shorter than the maximum length,
    // Return the whole text.
    if (strlen(preg_replace('/<.*?>/', '', $text_filtre)) <= $length) {
      return $text;
    }
    // Splits all html-tags to scanable lines.
    preg_match_all('/(<.+?>)?([^<>]*)/s', $text, $lines, PREG_SET_ORDER);
    $total_length = strlen($ending);
    $open_tags = array();
    $truncate = '';
    foreach ($lines as $line_matchings) {
      // If there is any html-tag in this line, handle it and add it (uncounted)
      // To the output.
      if (!empty($line_matchings[1])) {
        // If it's an "empty element" with or without xhtml-conform.
        // Closing slash.
        if (preg_match('/^<(\s*.+?\/\s*|\s*(img|br|input|hr|area|base|basefont|col|frame|isindex|link|meta|param)(\s.+?)?)>$/is', $line_matchings[1])) {
          // Do nothing
          // If tag is a closing tag.
        }
        else {
          if (preg_match('/^<\s*\/([^\s]+?)\s*>$/s', $line_matchings[1], $tag_matchings)) {
            // Delete tag from $open_tags list.
            $pos = array_search($tag_matchings[1], $open_tags);
            if ($pos !== FALSE) {
              unset($open_tags[$pos]);
            }
            // If tag is an opening tag.
          }
          else {
            if (preg_match('/^<\s*([^\s>!]+).*?>$/s', $line_matchings[1], $tag_matchings)) {
              // Add tag to the beginning of $open_tags list.
              array_unshift($open_tags, strtolower($tag_matchings[1]));
            }
          }
        }
        // Add html-tag to $truncate'd text.
        $truncate .= $line_matchings[1];
      }
      // Calculate the length of the plain text part of the line; handle.
      // Entities as one character.
      $content_length = strlen(
        preg_replace('/&[0-9a-z]{2,8};|&#[0-9]{1,7};|[0-9a-f]{1,6};/i', ' ', $line_matchings[2]));
      if ($total_length + $content_length > $length) {
        // The number of characters which are left.
        $left = $length - $total_length;
        $entities_length = 0;
        // Search for html entities.
        if (preg_match_all('/&[0-9a-z]{2,8};|&#[0-9]{1,7};|[0-9a-f]{1,6};/i', $line_matchings[2], $entities, PREG_OFFSET_CAPTURE)) {
          // Calculate the real length of all entities in the legal range.
          foreach ($entities[0] as $entity) {
            if ($entity[1] + 1 - $entities_length <= $left) {
              $left--;
              $entities_length += strlen($entity[0]);
            }
            else {
              // no more characters left
              break;
            }
          }
        }
        $truncate .= substr($line_matchings[2], 0, $left + $entities_length);
        // Maximum lenght is reached, so get off the loop.
        break;
      }
      else {
        $truncate .= $line_matchings[2];
        $total_length += $content_length;
      }
      // If the maximum length is reached, get off the loop.
      if ($total_length >= $length) {
        break;
      }
    }
  }
  else {
    if (strlen($text) <= $length) {
      return $text;
    }
    else {
      $truncate = substr($text, 0, $length - strlen($ending));
    }
  }
  // If the words shouldn't be cut in the middle.
  if (!$exact) {
    // Search the last occurance of a space.
    $spacepos = strrpos($truncate, ' ');
    if (isset($spacepos)) {
      // And cut the text in this position.
      $truncate = substr($truncate, 0, $spacepos);
    }
  }
  // Add the defined ending to the text.
  $truncate .= $ending;
  if ($consider_html) {
    // Close all unclosed html-tags.
    foreach ($open_tags as $tag) {
      $truncate .= '</' . $tag . '>';
    }
  }
  return $truncate;
}

/**
 * Is Attached To Content
 * @param type $nid
 *
 * @param type $content_attached
 *
 * @param type $content_attaching
 *
 * @return boolean
 */
function drs_global_functions_isAttachedToContent($nid, $content_attached = 'article', $content_attaching = 'magazine') {
  $query = new EntityFieldQuery();

  $field = "field_" . $content_attached;

  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', $content_attaching)
    ->fieldCondition($field, 'target_id', $nid, '=');

  $result = $query->execute();

  if ($result && isset($result['node'])) {
    return key($result['node']);
  }
  return FALSE;
}

/**
 * Convert Month To French.
 *
 * @param string $month
 *   month.
 * @return string french
 *   month.
 *
 */
function global_functions_convertMonthEnToFr($month) {
  switch ($month) {
    case "January": $mois = "Janvier";
      break;

    case "February": $mois = "Février";
      break;

    case "March": $mois = "Mars";
      break;

    case "April": $mois = "Avril";
      break;

    case "May": $mois = "Mai";
      break;

    case "June": $mois = "Juin";
      break;

    case "July": $mois = "Juillet";
      break;

    case "August": $mois = "Août";
      break;

    case "September": $mois = "Septembre";
      break;

    case "October": $mois = "Octobre";
      break;

    case "November": $mois = "Novembre";
      break;

    case "December": $mois = "Décembre";
      break;

    default: $mois = $month;
  }
  return $mois;
}

/**
 * Implements function that get filesize and node to with the file is attached.
 *
 * @param string $file_id
 *   file_id.
 * @return array
 *   variables.
 */
function drs_global_functions_fileGetInfos($file_id = NULL) {
  $variables = array();
  /* @var $info Drupal */
  $info = db_select(' file_managed', 'f')
      ->fields('f', array('filesize'))
      ->condition('f.fid', $file_id, '=')
      ->execute()->fetchAssoc();
  if (!empty($info) && isset($info['filesize'])) {
    $variables['filesize'] = drs_global_functions_formatSizeUnits($info['filesize']);
  }
  /* @var $info Drupal */
  $info = db_select('apachesolr_index_entities_file', 'a')
      ->condition('a.parent_entity_type', 'node', '=')
      ->condition('a.entity_id', $file_id, '=')
      ->fields('a', array('parent_entity_id'))
      ->execute()->fetchAssoc();
  if (!empty($info) && isset($info['parent_entity_id'])) {
    $info = db_select('node', 'n')->fields('n', array('nid', 'title', 'type'))
        ->execute()->fetchAssoc();
    if (!empty($info)) {
      if (isset($info['nid'])) {
        $variables['nid'] = $info['nid'];
      }
      if (isset($info['title'])) {
        $variables['title'] = $info['title'];
      }
    }
  }
  return $variables;
}

/**
 * Format Size Units.
 *
 * @param string $bytes
 *   Bytes.
 * @return string
 *   Units.
 */
function drs_global_functions_formatSizeUnits($bytes) {
  if ($bytes >= 1073741824) {
    $bytes = number_format($bytes / 1073741824, 2) . ' GO';
  }
  elseif ($bytes >= 1048576) {
    $bytes = number_format($bytes / 1048576, 2) . ' MO';
  }
  elseif ($bytes >= 1) {
    $bytes = number_format($bytes / 1024, 2) . ' KO';
  }
  else {
    $bytes = '0 O';
  }

  return $bytes;
}

/**
 * Convert Time From Seconds To Hour Minutes Secondes.
 *
 * @param string $seconds
 *   seconds
 * @return string
 *   hours.
 */
function drs_global_functions_convertFromSecondsToHourMinutesSecondes($seconds) {
  $output = '';
  if ($seconds >= 3600) {
    $hours = (int) ($seconds / 3600);
    $output .= $hours . 'h ';
    $rest = (int) ($seconds % 3600);
    if ($rest != 0) {
      $minutes = (int) ($rest / 60);
      $output .= $minutes . 'min ';
      $seconds = (int) ($rest % 60);
      $output .= $seconds . 's ';
    }
  }
  elseif ($seconds >= 60) {
    $minutes = (int) ($seconds / 60);
    $output .= $minutes . 'min ';
    $seconds = (int) ($seconds % 60);
    $output .= $seconds . 's ';
  }
  else {
    $output .= $seconds . 's ';
  }
  return $output;
}

/**
 * Previous Next Actuality.
 * @param type $current_node
 * @param type $op
 * @return string link
 */
function prev_next_node($current_node = NULL, $op = 'p', $node_type) {
  if ($op == 'n') {
    $sql_op = '>';
    $order = "ASC";
  }
  elseif ($op == 'p') {
    $sql_op = '<';
    $order = "DESC";
  }
  else {
    return NULL;
  }
  $result = db_select('node', 'n')
      ->fields('n', array('nid'))
      ->condition('created', $current_node->created, $sql_op)
      ->condition('type', array($node_type), 'IN')
      ->condition('status', 1, '=')
      ->orderBy('created', $order)
      ->execute()->fetchObject();
  if (is_object($result)) {
    switch ($node_type) {
      case "actuality": $next = t("Actualité suivante");
        $prev = t("Actualité précédente");
        break;

      case "turnover" : $next = t("Chiffre suivant");
        $prev = t("Chiffre précédent");
        break;

      case "publication" : $next = t("Publication suivante");
        $prev = t("Publication précédente");
        break;
    }
    if ($op == 'n') {
      $options['attributes'] = array('class' => 'pull-right');
      $options['html'] = TRUE;
      return l($next . ' >>', "node/" . $result->nid, $options);
    }
    if ($op == 'p') {
      $options['attributes'] = array('class' => 'pull-left');
      $options['html'] = TRUE;
      return l(t('<<') . ' ' . $prev, "node/" . $result->nid, $options);
    }
  }
}

/**
 * Implementation of hook_webform_select_options_info.
 * @return mixed
 *   items array.
 */
function drs_global_functions_webform_select_options_info() {
  $items = array();
  $vocabularies = taxonomy_get_vocabularies();
  foreach ($vocabularies as $voc) {
    // Add a setting that enables each vocabulary to be shown here.
    $items[$voc->vid] = array('title' => $voc->name,
      'options callback' => 'drs_global_functions_vocabulary_terms', 'options arguments' => $voc->vid);
  }
  return $items;
}

/**
 * Option list containing all terms of specified vocabulary.
 *
 * @param type $component
 *   component.
 *
 * @param type $flat
 *   flat.
 *
 * @param type $filter
 *   filter.
 *
 * @param type $vid
 *   vid.
 *
 * @return string
 *   terms.
 */
function drs_global_functions_vocabulary_terms($component, $flat, $filter, $vid) {
  $terms = array();
  $tree = taxonomy_get_tree($vid);
  $use_i18n = module_exists('i18n_taxonomy');
  foreach ($tree as $term) {
    $prefix = '';
    if (!$flat) {
      $prefix = str_repeat('-', $term->depth);
    }
    if ($use_i18n) {
      $terms[$term->tid] = $prefix . i18n_taxonomy_term_name($term);
    }
    else {
      $terms[$term->tid] = $prefix . $term->name;
    }
  }
  return $terms;
}

/**
 * Redirection Submit.
 *
 * @param object $form
 *   form.
 *
 * @param array $form_state
 *   form_state.
 */
function drs_global_functions_webform_client_redirection_submit(&$form, &$form_state) {
  if (isset($form_state['values']['submitted']['field_profile'])) {
    $tid = $form_state['values']['submitted']['field_profile'];
    $options = array('query' => array('field_background_profil_tid' => $tid,
        'field_background_theme_tid' => 'All')
    );
    drupal_goto('panorama', $options);
  }
}

/**
 * Get Minisite Variables.
 * @param type $node
 * @return Array
 */
function drs_global_functions_getMinisiteVariables($node) {
  $vars = array();
// Get header nformations
  if (isset($node->field_minisite_header['und'][0]['value'])) {
    $vars['header'] = $node->field_minisite_header['und'][0]['value'];
      if (isset($node->field_minisite_logo['und'][0]['uri'])) {
        $vars['logo'] = $node->field_minisite_logo['und'][0]['uri'];
      }
     
    
    if ($node->field_minisite_header['und'][0]['value'] == 'Bannière') {
      if (isset($node->field_minisite_banner['und'][0]['uri'])) {
        $vars['banner'] = $node->field_minisite_banner['und'][0]['uri'];
      }
    } 
    if (isset($node->field_minisite_color_banner['und'][0]['jquery_colorpicker'])) {
        $vars['background_color'] = $node->field_minisite_color_banner['und'][0]['jquery_colorpicker'];
      }
  }
  // Get fond informations if mini-site is attached to a background.
  if (drs_global_functions_isAttachedContent($node->nid, 'minisite', 'background') != FALSE) {
    $nid_fond = drs_global_functions_isAttachedContent($node->nid, 'minisite', 'background');
    $node_fond = node_load($nid_fond);
    $vars['title'] = $node_fond->title;
  }
  return $vars;
}

/**
 * This function allows to render a block created by module.
 * It is called in the confirmation page of order checkout.
 *
 * @param object $module
 *   object.
 * @param object $block_id
 *   object.
 * @return object
 *   object.
 */
function drs_global_functions_renderBlocks($module, $block_id) {
  $block = block_load($module, $block_id);
  if (is_object($block) && isset($block->delta)) {
    $block = _block_render_blocks(array($block));
    $block = _block_get_renderable_array($block);
  }

  return $block;
}

/**
 * Return Block Info.
 * @return string
 *   block.
 */
function drs_global_functions_block_info() {
  $block = array();
  $block['block_menu_minisite'] = array(
    'info' => t('Block des menus du minisite'),
    'status' => TRUE,
    'region' => 'sidebar_first',
    'visibility' => BLOCK_VISIBILITY_PHP);
  return $block;
}

/**
 * Retun block view.
 *
 * @param string $delta
 *   delta.
 * @return mixed
 *   return.
 */
function drs_global_functions_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'block_menu_minisite':
      $block['subject'] = t('Menu mini-site');
      $block['content'] = '';
      if (arg(0) == 'node' && is_numeric(arg(1)) || (arg(0) == "contact" && isset($_GET['nid']) && is_numeric($_GET['nid']))) {
        $nid = (isset($_GET['nid'])) ? intval($_GET['nid']) : arg(1);
        $node_first = node_load($nid);
        if (is_object($node_first) && isset($node_first->type) && !empty($node_first->field_minisite)) {
          $node = $node_first->field_minisite['und'][0]['entity'];
        }
        else {
          $node = $node_first;
        }
        if (is_object($node) && isset($node->type) && $node->type == "minisite") {
          $menu_sup = menu_tree_all_data('menu-menu-sup-rieur');
          $count = 0;
          $links = array();
          foreach ($menu_sup as $key => $menu_sup_details) {
            if ($count == 1) {
              $links[][$key] = $menu_sup_details;
              break;
            }
            else
              $count++;
          }
          $mini_site_title = str_replace(' ', '-', $node->title);
          $menu_name = 'menu-site-' . $mini_site_title;
          $links[] = menu_tree_all_data($menu_name);
          $block['content'] = theme('theme_block_menu_mini_site', array('links' => $links));
        }
      }
      break;
  }
  return $block;
}

/**
 * This function returns the nid of the node  which the given node nid is attached to.
 *
 * @param string $nid
 *   nid.
 *
 * @param string $type
 *   type.
 * @return string
 *   string.
 */
function drs_global_functions_isAttachedContent($nid, $type_relatedto, $type_relating_with = 'background') {
  $query = new EntityFieldQuery();
  $field = "field_" . $type_relatedto;
  $query->entityCondition('entity_type', 'node')->entityCondition('bundle', $type_relating_with)->fieldCondition($field, 'target_id', $nid, '=');
  $result = $query->execute();
  if ($result && isset($result['node'])) {
    return key($result['node']);
  }
  return FALSE;
}

/**
 * Extract Tags.
 *
 * @param string $data
 *   data HTML.
 *
 * @param array $tags
 *   tags returned.
 *
 * @param array $filtred_tags
 *   tags filtred.
 * @return \stdClass
 *   Return Tags as Object
 */
function drs_global_functions_extract_tags($data, $tags = array(), $filtred_tags = array()) {
  $matches = array(
    "h1" => "/<h1>(.*)<\/h1>/",
    "h2" => "/<h2>(.*)<\/h2>/",
    "h3" => "/<h3>(.*)<\/h3>/",
    "h4" => "/<h4>(.*)<\/h4>/",
    "h5" => "/<h5>(.*)<\/h5>/",
    "h6" => "/<h6>(.*)<\/h6>/",
    "img" => "/<img[^>]+\>/i");

  $return = new stdClass();
  $return->content = $data;
  $data_tag = array();
  if (!empty($tags)) {
    foreach ($tags as $tag) {
      preg_match($matches[$tag], $data, $data_tag);
      $return->{$tag} = (!empty($data_tag[0])) ? $data_tag[0] : '';
      $return->content = str_replace($return->{$tag}, '', $return->content);
    }
  }
  if (!empty($filtred_tags)) {
    $allowed_tags = implode(",", $filtred_tags);
    $return->content = strip_tags(trim($return->content), $allowed_tags);
  }
  else {
    $return->content = strip_tags(trim($return->content));
  }
  return $return;
}

/**
 * Get Other Publication of Author.
 *
 * @param object $author
 *   Author Node.
 *
 * @param type $node
 *   Publication Node.
 * @return mixed
 *   results.
 */
function drs_global_functions_get_other_publication($author, $node) {
  $query = db_select('node', 'n');
  $query->innerJoin('field_data_body', 'fdb', 'n.nid = fdb.entity_id');
  $query->innerJoin('field_data_field_image', 'fi', 'n.nid = fi.entity_id');
  $query->innerJoin('field_data_field_publication_author', 'fa', '(n.nid = fa.entity_id AND fa.field_publication_author_target_id = :param)', array(':param' => $author->nid));
  $query->fields('n', array('nid', 'title'))
    ->fields('fdb', array('body_summary'))
    ->fields('fi');
  $query->condition('n.type', array($node->type), 'IN')
    ->condition('n.nid', array($node->nid), 'NOT IN')
    ->condition('n.status', '1', '=')
    ->orderBy('n.created');
  $result = $query->execute()->fetchAll();
  if (!empty($result)) {
    return $result;
  }
  else {
    return FALSE;
  }
}

/**
 * Get Other Publication of Author.
 * @return mixed
 *   get last publication.
 */
function drs_global_functions_get_last_publication() {
  $query = db_select('node', 'n');
  $query->innerJoin('field_data_field_publication_type', 'fpt', 'n.nid = fpt.entity_id AND (fpt.field_publication_type_value = :param1 OR fpt.field_publication_type_value = :param2 )', array(':param1' => 'QRS cahiers', ':param2' => 'QRS études')
  );
  $query->fields('fpt', array('field_publication_type_value'));
  $query->condition('n.type', array('publication'), 'IN')
    ->condition('n.status', '1', '=')
    ->orderBy('n.created', 'DESC')
    ->range(0, 1);
  $result = $query->execute()->fetchObject();
  if (!empty($result)) {
    return $result;
  }
  else {
    return FALSE;
  }
}

/**
 * Get Presentation from portalconfig.
 * @see portal_config
 * @return mixed
 *   FALSE or array of nodes.
 */
function drs_global_functions_get_presentation() {
  $nids = array();

  for ($i = 1; $i < 7; $i++) {
    $var_return = variable_get('presentation_bloc_' . $i, '');
    if ($var_return != '') {
      $node_id = explode('node/', $var_return);
      if (isset($node_id[1]) && is_numeric($node_id[1])) {
        $nids[] = $node_id[1];
      }
    }
  }
  if (!empty($nids)) {
    $nodes = node_load_multiple($nids);
  }
  else {
    return FALSE;
  }
  return $nodes;
}
